<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ProcessMemoryUtilities.Native</name>
    </assembly>
    <members>
        <member name="T:ProcessMemoryUtilities.Native.AllocationType">
            <summary>
            Defines the different types of memory allocations.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.AllocationType.Invalid">
            <summary>
            An invalid value.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.AllocationType.Commit">
            <summary>
            Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The
            function also guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not
            allocated unless/until the virtual addresses are actually accessed. To reserve and commit pages in one step, call VirtualAllocEx with
            MEM_COMMIT | MEM_RESERVE. Attempting to commit a specific address range by specifying MEM_COMMIT without MEM_RESERVE and a non-NULL
            lpAddress fails unless the entire range has already been reserved. The resulting error code is ERROR_INVALID_ADDRESS. An attempt to commit
            a page that is already committed does not cause the function to fail. This means that you can commit pages without first determining the
            current commitment state of each page. If lpAddress specifies an address within an enclave, flAllocationType must be MEM_COMMIT.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.AllocationType.Reserve">
            <summary>
            Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on
            disk. You commit reserved pages by calling VirtualAllocEx again with MEM_COMMIT. To reserve and commit pages in one step, call
            VirtualAllocEx with MEM_COMMIT | MEM_RESERVE. Other memory allocation functions, such as malloc and LocalAlloc, cannot use reserved memory
            until it has been released.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.AllocationType.Reset">
            <summary>
            Indicates that data in the memory range specified by lpAddress and dwSize is no longer of interest. The pages should not be read from or
            written to the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used
            with any other value. Using this value does not guarantee that the range operated on with MEM_RESET will contain zeros. If you want the
            range to contain zeros, decommit the memory and then recommit it. When you use MEM_RESET, the VirtualAllocEx function ignores the value of
            fProtect. However, you must still set fProtect to a valid protection value, such as PAGE_NOACCESS. VirtualAllocEx returns an error if you
            use MEM_RESET and the range of memory is mapped to a file. A shared view is only acceptable if it is mapped to a paging file.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.AllocationType.TopDown">
            <summary>
            Allocates memory at the highest possible address. This can be slower than regular allocations, especially when there are many allocations.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.AllocationType.WriteWatch">
            <summary>
            Causes the system to track pages that are written to in the allocated region. If you specify this value, you must also specify MEM_RESERVE.
            To retrieve the addresses of the pages that have been written to since the region was allocated or the write-tracking state was reset, call
            the GetWriteWatch function. To reset the write-tracking state, call GetWriteWatch or ResetWriteWatch. The write-tracking feature remains
            enabled for the memory region until the region is freed.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.AllocationType.Physical">
            <summary>
            Reserves an address range that can be used to map Address Windowing Extensions (AWE) pages. This value must be used with MEM_RESERVE and no
            other values.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.AllocationType.ResetUndo">
            <summary>
            MEM_RESET_UNDO should only be called on an address range to which MEM_RESET was successfully applied earlier. It indicates that the data in
            the specified memory range specified by lpAddress and dwSize is of interest to the caller and attempts to reverse the effects of MEM_RESET.
            If the function succeeds, that means all data in the specified address range is intact. If the function fails, at least some of the data in
            the address range has been replaced with zeroes. This value cannot be used with any other value. If MEM_RESET_UNDO is called on an address
            range which was not MEM_RESET earlier, the behavior is undefined. When you specify MEM_RESET, the VirtualAllocEx function ignores the value
            of flProtect. However, you must still set flProtect to a valid protection value, such as PAGE_NOACCESS. Windows Server 2008 R2, Windows 7,
            Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: The MEM_RESET_UNDO flag is not supported until Windows 8 and
            Windows Server 2012.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.AllocationType.LargePages">
            <summary>
            Allocates memory using large page support. The size and alignment must be a multiple of the large-page minimum. To obtain this value, use
            the GetLargePageMinimum function. If you specify this value, you must also specify MEM_RESERVE and MEM_COMMIT.
            </summary>
        </member>
        <member name="T:ProcessMemoryUtilities.Native.FreeType">
            <summary>
            Defines the different types of free operations.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.FreeType.Invalid">
            <summary>
            An invalid value.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.FreeType.CoalescePlaceholders">
            <summary>
            To coalesce two adjacent placeholders, specify MEM_RELEASE | MEM_COALESCE_PLACEHOLDERS. When you coalesce placeholders, lpAddress and
            dwSize must exactly match those of the placeholder.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.FreeType.PreservePlaceholder">
            <summary>
            Frees an allocation back to a placeholder (after you've replaced a placeholder with a private allocation using VirtualAlloc2 or
            Virtual2AllocFromApp). To split a placeholder into two placeholders, specify MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.FreeType.Decommit">
            <summary>
            Decommits the specified region of committed pages. After the operation, the pages are in the reserved state. The function does not fail if
            you attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining their current
            commitment state. Do not use this value with MEM_RELEASE. The MEM_DECOMMIT value is not supported when the lpAddress parameter provides the
            base address for an enclave.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.FreeType.Release">
            <summary>
            Releases the specified region of pages, or placeholder (for a placeholder, the address space is released and available for other
            allocations). After the operation, the pages are in the free state. If you specify this value, dwSize must be 0 (zero), and lpAddress must
            point to the base address returned by the VirtualAllocEx function when the region is reserved. The function fails if either of these
            conditions is not met. If any pages in the region are committed currently, the function first decommits, and then releases them. The
            function does not fail if you attempt to release pages that are in different states, some reserved and some committed. This means that you
            can release a range of pages without first determining the current commitment state. Do not use this value with MEM_DECOMMIT.
            </summary>
        </member>
        <member name="T:ProcessMemoryUtilities.Native.MemoryProtectionFlags">
            <summary>
            Defines the memory protection constants.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.MemoryProtectionFlags.Invalid">
            <summary>
            An invalid value.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.MemoryProtectionFlags.NoAccess">
            <summary>
            Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an
            access violation. This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.MemoryProtectionFlags.ReadOnly">
            <summary>
            Enables read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. If
            Data Execution Prevention is enabled, an attempt to execute code in the committed region results in an access violation.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.MemoryProtectionFlags.ReadWrite">
            <summary>
            Enables read-only or read/write access to the committed region of pages. If Data Execution Prevention is enabled, attempting to execute
            code in the committed region results in an access violation.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.MemoryProtectionFlags.WriteCopy">
            <summary>
            Enables read-only or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page
            results in a private copy of the page being made for the process. The private page is marked as PAGE_READWRITE, and the change is written
            to the new page. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access
            violation. This flag is not supported by the VirtualAlloc or VirtualAllocEx functions.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.MemoryProtectionFlags.Execute">
            <summary>
            Enables execute access to the committed region of pages. An attempt to write to the committed region results in an access violation. This
            flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.MemoryProtectionFlags.ExecuteRead">
            <summary>
            Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region results in an access
            violation. Windows Server 2003 and Windows XP: This attribute is not supported by the CreateFileMapping function until Windows XP with SP2
            and Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.MemoryProtectionFlags.ExecuteReadWrite">
            <summary>
            Enables execute, read-only, or read/write access to the committed region of pages. Windows Server 2003 and Windows XP: This attribute is
            not supported by the CreateFileMapping function until Windows XP with SP2 and Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.MemoryProtectionFlags.ExecuteWriteCopy">
            <summary>
            Enables execute, read-only, or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed
            copy-on-write page results in a private copy of the page being made for the process. The private page is marked as PAGE_EXECUTE_READWRITE,
            and the change is written to the new page. This flag is not supported by the VirtualAlloc or VirtualAllocEx functions. Windows Vista,
            Windows Server 2003 and Windows XP: This attribute is not supported by the CreateFileMapping function until Windows Vista with SP1 and
            Windows Server 2008.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.MemoryProtectionFlags.GuardModifierflag">
            <summary>
            Pages in the region become guard pages. Any attempt to access a guard page causes the system to raise a STATUS_GUARD_PAGE_VIOLATION
            exception and turn off the guard page status. Guard pages thus act as a one-time access alarm. For more information, see Creating Guard
            Pages. When an access attempt leads the system to turn off guard page status, the underlying page protection takes over. If a guard page
            exception occurs during a system service, the service typically returns a failure status indicator. This value cannot be used with
            PAGE_NOACCESS. This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.MemoryProtectionFlags.NoCacheModifierflag">
            <summary>
            Sets all pages to be non-cachable. Applications should not use this attribute except when explicitly required for a device. Using the
            interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception. The
            PAGE_NOCACHE flag cannot be used with the PAGE_GUARD, PAGE_NOACCESS, or PAGE_WRITECOMBINE flags. The PAGE_NOCACHE flag can be used only
            when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable non-cached memory access
            for shared memory, specify the SEC_NOCACHE flag when calling the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.MemoryProtectionFlags.WriteCombineModifierflag">
            <summary>
            Sets all pages to be write-combined. Applications should not use this attribute except when explicitly required for a device. Using the
            interlocked functions with memory that is mapped as write-combined can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception. The
            PAGE_WRITECOMBINE flag cannot be specified with the PAGE_NOACCESS, PAGE_GUARD, and PAGE_NOCACHE flags. The PAGE_WRITECOMBINE flag can be
            used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable write-combined
            memory access for shared memory, specify the SEC_WRITECOMBINE flag when calling the CreateFileMapping function. Windows Server 2003 and
            Windows XP: This flag is not supported until Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="T:ProcessMemoryUtilities.Native.NtStatus">
            <summary>
            Contains all NTSTATUS codes that could possibly happen when using this library. These may be incomplete.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.NtStatus.SUCCESS">
            <summary>
            STATUS_SUCCESS
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.NtStatus.DATATYPE_MISALIGNMENT">
            <summary>
            A datatype misalignment was detected in a load or store instruction.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.NtStatus.PARTIAL_COPY">
            <summary>
            Due to protection conflicts not all the requested bytes could be copied.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.NtStatus.ACCESS_VIOLATION">
            <summary>
            The instruction at 0x%p referenced memory at 0x%p. The memory could not be %s.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.NtStatus.INVALID_HANDLE">
            <summary>
            An invalid HANDLE was specified.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.NtStatus.ACCESS_DENIED">
            <summary>
            A process has requested access to an object, but has not been granted those access rights.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.NtStatus.OBJECT_TYPE_MISMATCH">
            <summary>
            There is a mismatch between the type of object required by the requested operation and the type of object that is specified in the request.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.NtStatus.INSUFFICIENT_RESOURCES">
            <summary>
            Insufficient system resources exist to complete the API.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.NtStatus.PROCESS_IS_TERMINATING">
            <summary>
            An attempt was made to access an exiting process.
            </summary>
        </member>
        <member name="T:ProcessMemoryUtilities.Native.ProcessAccessFlags">
            <summary>
            Defines process security and access rights.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.Invalid">
            <summary>
            An invalid value.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.Terminate">
            <summary>
            Required to terminate a process using TerminateProcess.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.CreateThread">
            <summary>
            Required to create a thread.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.Allocate">
            <summary>
            Required to allocate memory in the address space of another process.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.VirtualMemoryOperation">
            <summary>
            Required to perform an operation on the address space of a process (see VirtualProtectEx and WriteProcessMemory).
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.Read">
            <summary>
            Required to read memory in a process using ReadProcessMemory.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.VirtualMemoryRead">
            <summary>
            Required to read memory in a process using ReadProcessMemory.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.VirtualMemoryWrite">
            <summary>
            Combine with VirtualMemoryOperation for Write access.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.Write">
            <summary>
            Required to write to memory in a process using WriteProcessMemory.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.ReadWrite">
            <summary>
            Combines read and write access of a process memory.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.DuplicateHandle">
            <summary>
            Required to duplicate a handle using DuplicateHandle.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.CreateProcess">
            <summary>
            Required to create a process.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.SetQuota">
            <summary>
            Required to set memory limits using SetProcessWorkingSetSize.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.SetInformation">
            <summary>
            Required to set certain information about a process, such as its priority class (see SetPriorityClass).
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.QueryInformation">
            <summary>
            Required to retrieve certain information about a process, such as its token, exit code, and priority class (see OpenProcessToken).
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.SuspendResume">
            <summary>
            Required to set memory limits using SetProcessWorkingSetSize.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.QueryLimitedInformation">
            <summary>
            Required to retrieve certain information about a process (see GetExitCodeProcess, GetPriorityClass, IsProcessInJob,
            QueryFullProcessImageName). A handle that has the PROCESS_QUERY_INFORMATION access right is automatically granted
            PROCESS_QUERY_LIMITED_INFORMATION.Windows Server 2003 and Windows XP: This access right is not supported.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.Information">
            <summary>
            Required to query information from another process.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.Execute">
            <summary>
            Required when using CreateRemoteThread(Ex) to execute code in a another process.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.Synchronize">
            <summary>
            Required to wait for the process to terminate using the wait functions.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ProcessAccessFlags.All">
            <summary>
            All possible access rights for a process object.Windows Server 2003 and Windows XP: The size of the PROCESS_ALL_ACCESS flag increased on
            Windows Server 2008 and Windows Vista. If an application compiled for Windows Server 2008 and Windows Vista is run on Windows Server 2003
            or Windows XP, the PROCESS_ALL_ACCESS flag is too large and the function specifying this flag fails with ERROR_ACCESS_DENIED. To avoid this
            problem, specify the minimum set of access rights required for the operation. If PROCESS_ALL_ACCESS must be used, set _WIN32_WINNT to the
            minimum operating system targeted by your application (for example, #define _WIN32_WINNT _WIN32_WINNT_WINXP). For more information, see
            Using the Windows Headers.
            </summary>
        </member>
        <member name="T:ProcessMemoryUtilities.Native.ThreadCreationFlags">
            <summary>
            Defines flags that control the creation of a remote thread.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ThreadCreationFlags.Immediately">
            <summary>
            The thread runs immediately after creation.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ThreadCreationFlags.Suspended">
            <summary>
            The thread is created in a suspended state and does not run until the ResumeThread function is called.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.ThreadCreationFlags.StackSizeParamIsAReservation">
            <summary>
            The dwStackSize parameter specifies the initial reserve size of the stack. If this flag is not specified, dwStackSize specifies the commit
            size.
            </summary>
        </member>
        <member name="T:ProcessMemoryUtilities.Native.WaitObjectResult">
            <summary>
            Defines the events that cause a function like WaitForSingleObject to return.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.WaitObjectResult.Success">
            <summary>
            The state of the specified object is signaled.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.WaitObjectResult.Abandoned">
            <summary>
            The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated.
            Ownership of the mutex object is granted to the calling thread and the mutex state is set to nonsignaled. If the mutex was protecting
            persistent state information, you should check it for consistency.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.WaitObjectResult.Timeout">
            <summary>
            The time-out interval elapsed, and the object's state is nonsignaled.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.WaitObjectResult.Failed">
            <summary>
            The function has failed. To get extended error information, call GetLastError.
            </summary>
        </member>
        <member name="T:ProcessMemoryUtilities.Native.Kernel32">
            <summary>
            Provides access to some methods of kernel32.dll
            </summary>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.Kernel32.CreateRemoteThreadEx(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.
            </summary>
            <param name="handle">A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights.</param>
            <param name="startAddress">A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process.</param>
            <param name="parameter">A pointer to a variable to be passed to the thread function pointed to by lpStartAddress. This parameter can be IntPtr.Zero.</param>
            <returns>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is IntPtr.Zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.Kernel32.CreateRemoteThreadEx(System.IntPtr,System.IntPtr,System.IntPtr,ProcessMemoryUtilities.Native.ThreadCreationFlags)">
            <summary>
            Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.
            </summary>
            <param name="handle">A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights.</param>
            <param name="startAddress">A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process.</param>
            <param name="parameter">A pointer to a variable to be passed to the thread function pointed to by lpStartAddress. This parameter can be IntPtr.Zero.</param>
            <param name="creationFlags">The flags that control the creation of the thread.</param>
            <returns>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is IntPtr.Zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.Kernel32.CreateRemoteThreadEx(System.IntPtr,System.IntPtr,System.IntPtr,ProcessMemoryUtilities.Native.ThreadCreationFlags,System.UInt32@)">
            <summary>
            Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.
            </summary>
            <param name="handle">A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights.</param>
            <param name="startAddress">A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process.</param>
            <param name="parameter">A pointer to a variable to be passed to the thread function pointed to by lpStartAddress. This parameter can be IntPtr.Zero.</param>
            <param name="creationFlags">The flags that control the creation of the thread.</param>
            <param name="threadId">A variable that receives the thread identifier.</param>
            <returns>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is IntPtr.Zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.Kernel32.CreateRemoteThreadEx(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,ProcessMemoryUtilities.Native.ThreadCreationFlags,System.IntPtr,System.UInt32@)">
            <summary>
            Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.
            </summary>
            <param name="handle">A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights.</param>
            <param name="threadAttributes">A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If lpThreadAttributes is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator.</param>
            <param name="stackSize">The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable.</param>
            <param name="startAddress">A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process.</param>
            <param name="parameter">A pointer to a variable to be passed to the thread function pointed to by lpStartAddress. This parameter can be IntPtr.Zero.</param>
            <param name="creationFlags">The flags that control the creation of the thread.</param>
            <param name="attributeList">An attribute list that contains additional parameters for the new thread. This list is created by the InitializeProcThreadAttributeList function.</param>
            <param name="threadId">A variable that receives the thread identifier.</param>
            <returns>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is IntPtr.Zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.Kernel32.CreateRemoteThreadEx(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,ProcessMemoryUtilities.Native.ThreadCreationFlags,System.IntPtr,System.IntPtr)">
            <summary>
            Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor group affinity.
            </summary>
            <param name="handle">A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights.</param>
            <param name="threadAttributes">A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If lpThreadAttributes is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator.</param>
            <param name="stackSize">The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable.</param>
            <param name="startAddress">A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process.</param>
            <param name="parameter">A pointer to a variable to be passed to the thread function pointed to by lpStartAddress. This parameter can be IntPtr.Zero.</param>
            <param name="creationFlags">The flags that control the creation of the thread.</param>
            <param name="attributeList">An attribute list that contains additional parameters for the new thread. This list is created by the InitializeProcThreadAttributeList function.</param>
            <param name="threadId">A variable that receives the thread identifier.</param>
            <returns>If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is IntPtr.Zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="F:ProcessMemoryUtilities.Native.Kernel32.INFINITE">
            <summary>
            A constant used to specify an infinite waiting period
            </summary>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.Kernel32.OpenProcess(ProcessMemoryUtilities.Native.ProcessAccessFlags,System.Boolean,System.Int32)">
            <summary>
            Opens an existing local process object.
            </summary>
            <param name="desiredAccess">The access to the process object. This access right is checked against the security descriptor for the process.</param>
            <param name="inheritHandle">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
            <param name="processId">The identifier of the local process to be opened.</param>
            <returns>If the function succeeds, the return value is an open handle to the specified process. If the function fails, the return value is IntPtr.Zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.Kernel32.OpenProcess(ProcessMemoryUtilities.Native.ProcessAccessFlags,System.Int32)">
            <summary>
            Opens an existing local process object.
            </summary>
            <param name="desiredAccess">The access to the process object. This access right is checked against the security descriptor for the process.</param>
            <param name="processId">The identifier of the local process to be opened.</param>
            <returns>If the function succeeds, the return value is an open handle to the specified process. If the function fails, the return value is IntPtr.Zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.Kernel32.WaitForSingleObject(System.IntPtr,System.UInt32)">
            <summary>
            Waits until the specified object is in the signaled state or the time-out interval elapses.
            </summary>
            <param name="handle">A handle to the object.</param>
            <param name="timeout">The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the object is signaled.</param>
            <returns>If the function succeeds, the return value indicates the event that caused the function to return.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.Kernel32.GetRealWaitObjectResult(ProcessMemoryUtilities.Native.WaitObjectResult)">
            <summary>
            Turns the given WaitObjectResult into one of the defined enum values by stripping the objects index.
            </summary>
            <param name="value">A WaitObjectResult.</param>
            <returns>A WaitObjectResult which is guaranteed to be one of the defined enum values.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.Kernel32.GetRealWaitObjectResult(ProcessMemoryUtilities.Native.WaitObjectResult,System.Int32@)">
            <summary>
            Turns the given WaitObjectResult into one of the defined enum values and returns the objects index.
            </summary>
            <param name="value">A WaitObjectResult</param>
            <param name="index">A variable that receives the index of the awaited object.</param>
            <returns>A WaitObjectResult which is guaranteed to be one of the defined enum values.</returns>
        </member>
        <member name="T:ProcessMemoryUtilities.Native.NtDll">
            <summary>
            Provides access to some methods of ntdll.dll
            </summary>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.RtlNtStatusToDosError(System.UInt32)">
            <summary>
            Converts the specified NTSTATUS code to its equivalent system error code.
            </summary>
            <param name="value">The NTSTATUS code to be converted.</param>
            <returns>The function returns the corresponding system error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtSuccess(System.UInt32)">
            <summary>
            Checks if the specified NTSTATUS is a success or informational type.
            </summary>
            <param name="value">A NTSTATUS value.</param>
            <returns>Returns true if the specified NTSTATUS is a success or informational type.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtSuccessOnly(System.UInt32)">
            <summary>
            Checks if the specified NTSTATUS is a success type.
            </summary>
            <param name="value">A NTSTATUS value.</param>
            <returns>Returns true if the specified NTSTATUS is a success type.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtInformation(System.UInt32)">
            <summary>
            Checks if the specified NTSTATUS is a informational type.
            </summary>
            <param name="value">A NTSTATUS value.</param>
            <returns>Returns true if the specified NTSTATUS is a informational type.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWarning(System.UInt32)">
            <summary>
            Checks if the specified NTSTATUS is a warning type.
            </summary>
            <param name="value">A NTSTATUS value.</param>
            <returns>Returns true if the specified NTSTATUS is a warning type.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtError(System.UInt32)">
            <summary>
            Checks if the specified NTSTATUS is a error type.
            </summary>
            <param name="value">A NTSTATUS value.</param>
            <returns>Returns true if the specified NTSTATUS is a error type.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtClose(System.IntPtr)">
            <summary>
            Closes an open object handle.
            </summary>
            <param name="handle">A valid handle to an open object.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtOpenProcess(ProcessMemoryUtilities.Native.ProcessAccessFlags,System.Int32,System.IntPtr@)">
            <summary>
            Opens an existing local process object.
            </summary>
            <param name="desiredAccess">The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one or more of the process access rights.</param>
            <param name="processId">The identifier of the local process to be opened.</param>
            <param name="handle">A variable that receives the opened handle.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtOpenProcess(ProcessMemoryUtilities.Native.ProcessAccessFlags,System.Boolean,System.Int32,System.IntPtr@)">
            <summary>
            Opens an existing local process object.
            </summary>
            <param name="desiredAccess">The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one or more of the process access rights.</param>
            <param name="inheritHandle">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
            <param name="processId">The identifier of the local process to be opened.</param>
            <param name="handle">A variable that receives the opened handle.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="size">The number of bytes to be read from the specified process.</param>
            <param name="numberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer. If lpNumberOfBytesRead is IntPtr.Zero, the parameter is ignored.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr@)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="size">The number of bytes to be read from the specified process.</param>
            <param name="numberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="size">The number of bytes to be read from the specified process.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemory``1(System.IntPtr,System.IntPtr,``0@)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemory``1(System.IntPtr,System.IntPtr,``0@,System.IntPtr@)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="numberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer. If lpNumberOfBytesRead is IntPtr.Zero, the parameter is ignored.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.Int32,System.Int32)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="offset">A byte offset from inside the array to copy to.</param>
            <param name="length">The number of bytes to copy to the array.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.Int32,System.Int32,System.IntPtr@)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="offset">A byte offset from inside the array to copy to.</param>
            <param name="length">The number of bytes to copy to the array.</param>
            <param name="numberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer. If lpNumberOfBytesRead is IntPtr.Zero, the parameter is ignored.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.Int32)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="offset">A byte offset from inside the array to copy to.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.Int32,System.IntPtr@)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="offset">A byte offset from inside the array to copy to.</param>
            <param name="numberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryArray``1(System.IntPtr,System.IntPtr,``0[])">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.IntPtr@)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="numberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryPartial``1(System.IntPtr,System.IntPtr,``0@,System.Int32,System.Int32)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="offset">A byte offset from the start of the buffer.</param>
            <param name="length">The number of bytes to copy to the buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryPartial``1(System.IntPtr,System.IntPtr,``0@,System.Int32,System.Int32,System.IntPtr@)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="offset">A byte offset from the start of the buffer.</param>
            <param name="length">The number of bytes to copy to the buffer.</param>
            <param name="numberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryPartial``1(System.IntPtr,System.IntPtr,``0@,System.Int32)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="offset">A byte offset from the start of the buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtReadVirtualMemoryPartial``1(System.IntPtr,System.IntPtr,``0@,System.Int32,System.IntPtr@)">
            <summary>
            ReadProcessMemory copies the data in the specified address range from the address space of the specified process into the specified buffer of the current process. Any process that has a handle with PROCESS_VM_READ access can call the function. The entire area to be read must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="offset">A byte offset from the start of the buffer.</param>
            <param name="numberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtAllocateVirtualMemory(System.IntPtr,System.IntPtr,ProcessMemoryUtilities.Native.AllocationType,ProcessMemoryUtilities.Native.MemoryProtectionFlags,System.IntPtr@)">
            <summary>
            Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero.
            </summary>
            <param name="handle">The handle to a process. The function allocates memory within the virtual address space of this process. The handle must have the PROCESS_VM_OPERATION access right.For more information, see Process Security and Access Rights.</param>
            <param name="size">The size of the region of memory to allocate, in bytes.</param>
            <param name="allocationType">The type of memory allocation. Common flags are AllocationType.Commit | AllocationType.Reserve.</param>
            <param name="memoryProtection">The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants.</param>
            <param name="address">A pointer to a variable that receives the base address of the allocated region of pages.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtFreeVirtualMemory(System.IntPtr,System.IntPtr,System.IntPtr,ProcessMemoryUtilities.Native.FreeType)">
            <summary>
            Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process.
            </summary>
            <param name="handle">A handle to a process. The function frees memory within the virtual address space of the process. The handle must have the PROCESS_VM_OPERATION access right.For more information, see Process Security and Access Rights.</param>
            <param name="address">A pointer to the starting address of the region of memory to be freed. If the dwFreeType parameter is MEM_RELEASE, lpAddress must be the base address returned by the VirtualAllocEx function when the region is reserved.</param>
            <param name="size">The size of the region of memory to free, in bytes. If the dwFreeType parameter is MEM_RELEASE, dwSize must be 0 (zero). The function frees the entire region that is reserved in the initial allocation call to VirtualAllocEx. If dwFreeType is MEM_DECOMMIT, the function decommits all memory pages that contain one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted. If lpAddress is the base address returned by VirtualAllocEx and dwSize is 0 (zero), the function decommits the entire region that is allocated by VirtualAllocEx. After that, the entire region is in the reserved state.</param>
            <param name="freeType">The type of free operation. This parameter can be one of the FreeType values.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtProtectVirtualMemory(System.IntPtr,System.IntPtr,System.IntPtr,ProcessMemoryUtilities.Native.MemoryProtectionFlags,ProcessMemoryUtilities.Native.MemoryProtectionFlags@)">
            <summary>
            Changes the protection on a region of committed pages in the virtual address space of a specified process.
            </summary>
            <param name="handle">A handle to the process whose memory protection is to be changed. The handle must have the PROCESS_VM_OPERATION access right. For more information, see Process Security and Access Rights.</param>
            <param name="address">A pointer to the base address of the region of pages whose access protection attributes are to be changed. All pages in the specified region must be within the same reserved region allocated when calling the VirtualAlloc or VirtualAllocEx function using MEM_RESERVE. The pages cannot span adjacent reserved regions that were allocated by separate calls to VirtualAlloc or VirtualAllocEx using MEM_RESERVE.</param>
            <param name="size">The size of the region whose access protection attributes are changed, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be changed.</param>
            <param name="newProtection">The memory protection option. This parameter can be one of the MemoryProtectionFlags.</param>
            <param name="oldProtection">A pointer to a variable that receives the previous MemoryProtectionFlags of the first page in the specified region of pages.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="size">The number of bytes to be written to the specified process.</param>
            <param name="numberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is IntPtr.Zero, the parameter is ignored.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr@)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="size">The number of bytes to be written to the specified process.</param>
            <param name="numberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="size">The number of bytes to be written to the specified process.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemory``1(System.IntPtr,System.IntPtr,``0@)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemory``1(System.IntPtr,System.IntPtr,``0@,System.IntPtr@)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="numberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is IntPtr.Zero, the parameter is ignored.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.Int32,System.Int32)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="offset">A byte offset from inside the array to copy from.</param>
            <param name="length">The number of bytes to copy from the array.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.Int32,System.Int32,System.IntPtr@)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="offset">A byte offset from inside the array to copy from.</param>
            <param name="length">The number of bytes to copy from the array.</param>
            <param name="numberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If lpNumberOfBytesWritten is IntPtr.Zero, the parameter is ignored.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.Int32)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="offset">A byte offset from inside the array to copy from.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.Int32,System.IntPtr@)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="offset">A byte offset from inside the array to copy from.</param>
            <param name="numberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryArray``1(System.IntPtr,System.IntPtr,``0[])">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.IntPtr@)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="numberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryPartial``1(System.IntPtr,System.IntPtr,``0@,System.Int32,System.Int32)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="offset">A byte offset from the start of the buffer.</param>
            <param name="length">The number of bytes to copy to the buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryPartial``1(System.IntPtr,System.IntPtr,``0@,System.Int32,System.Int32,System.IntPtr@)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="offset">A byte offset from the start of the buffer.</param>
            <param name="length">The number of bytes to copy to the buffer.</param>
            <param name="numberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryPartial``1(System.IntPtr,System.IntPtr,``0@,System.Int32)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="offset">A byte offset from the start of the buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Native.NtDll.NtWriteVirtualMemoryPartial``1(System.IntPtr,System.IntPtr,``0@,System.Int32,System.IntPtr@)">
            <summary>
            WriteProcessMemory copies the data from the specified buffer in the current process to the address range of the specified process. Any process that has a handle with PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process to be written to can call the function. Typically but not always, the process with address space that is being written to is being debugged. The entire area to be written to must be accessible, and if it is not accessible, the function fails.
            </summary>
            <param name="handle">A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.</param>
            <param name="baseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="offset">A byte offset from the start of the buffer.</param>
            <param name="numberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns>Returns an NTSTATUS success or error code.</returns>
        </member>
    </members>
</doc>
